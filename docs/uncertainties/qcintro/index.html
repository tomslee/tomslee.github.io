<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tom Slee">
<meta name="dcterms.date" content="2024-10-16">
<meta name="description" content="A sceptical one, version 0.1">

<title>Yet Another Introduction to Quantum Computing – Tom Slee</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../logo.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>
<style>

      .quarto-title-block .quarto-title-banner {
        background: DarkCyan;
      }
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta name="twitter:title" content="Yet Another Introduction to Quantum Computing – Tom Slee">
<meta name="twitter:description" content="A sceptical one, version 0.1">
<meta name="twitter:image" content="images/clipboard-3934556282.png">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Tom Slee</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../essays.html"> 
<span class="menu-text">Essays</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../uncertainties.html"> 
<span class="menu-text">Uncertainties</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://tomslee.github.io/ridehail/lab/"> 
<span class="menu-text">Ridehail Lab</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Whimsley (blog archive)</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/tomslee"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/whimsley"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Yet Another Introduction to Quantum Computing</h1>
                  <div>
        <div class="description">
          <p>A sceptical one, version 0.1</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Uncertainties</div>
                <div class="quarto-category">Quantum Computing</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Tom Slee </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Last updated</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 16, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#the-building-block" id="toc-the-building-block" class="nav-link" data-scroll-target="#the-building-block"><span class="header-section-number">2</span> The building block</a>
  <ul class="collapse">
  <li><a href="#qubits" id="toc-qubits" class="nav-link" data-scroll-target="#qubits"><span class="header-section-number">2.1</span> Qubits</a></li>
  <li><a href="#gates" id="toc-gates" class="nav-link" data-scroll-target="#gates"><span class="header-section-number">2.2</span> Gates</a></li>
  <li><a href="#circuits" id="toc-circuits" class="nav-link" data-scroll-target="#circuits"><span class="header-section-number">2.3</span> Circuits</a></li>
  </ul></li>
  <li><a href="#will-i-have-a-quantum-laptop-no" id="toc-will-i-have-a-quantum-laptop-no" class="nav-link" data-scroll-target="#will-i-have-a-quantum-laptop-no"><span class="header-section-number">3</span> Will I have a quantum laptop? (No)</a></li>
  <li><a href="#how-to-program-a-quantum-computer" id="toc-how-to-program-a-quantum-computer" class="nav-link" data-scroll-target="#how-to-program-a-quantum-computer"><span class="header-section-number">4</span> How to program a quantum computer</a></li>
  <li><a href="#why-might-quantum-computing-matter" id="toc-why-might-quantum-computing-matter" class="nav-link" data-scroll-target="#why-might-quantum-computing-matter"><span class="header-section-number">5</span> Why might quantum computing matter?</a>
  <ul class="collapse">
  <li><a href="#superposition-and-interference" id="toc-superposition-and-interference" class="nav-link" data-scroll-target="#superposition-and-interference"><span class="header-section-number">5.1</span> Superposition and interference</a></li>
  <li><a href="#the-deutsch-algorithm" id="toc-the-deutsch-algorithm" class="nav-link" data-scroll-target="#the-deutsch-algorithm"><span class="header-section-number">5.2</span> The Deutsch algorithm</a></li>
  <li><a href="#the-canonical-algorithms" id="toc-the-canonical-algorithms" class="nav-link" data-scroll-target="#the-canonical-algorithms"><span class="header-section-number">5.3</span> The canonical algorithms</a></li>
  <li><a href="#quantum-simulation" id="toc-quantum-simulation" class="nav-link" data-scroll-target="#quantum-simulation"><span class="header-section-number">5.4</span> Quantum simulation</a></li>
  </ul></li>
  <li><a href="#quantum-computing-in-2024" id="toc-quantum-computing-in-2024" class="nav-link" data-scroll-target="#quantum-computing-in-2024"><span class="header-section-number">6</span> Quantum computing in 2024</a>
  <ul class="collapse">
  <li><a href="#current-state-of-the-art" id="toc-current-state-of-the-art" class="nav-link" data-scroll-target="#current-state-of-the-art"><span class="header-section-number">6.1</span> Current state of the art</a></li>
  </ul></li>
  <li><a href="#the-big-question" id="toc-the-big-question" class="nav-link" data-scroll-target="#the-big-question"><span class="header-section-number">7</span> The big question</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="qcintro.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div class="callout callout-style-default callout-note callout-titled" title="About this page">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
About this page
</div>
</div>
<div class="callout-body-container callout-body">
<p>Notes to myself, as I try to understand quantum computing without succumbing to mystification.</p>
</div>
</div>
<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>In as few words as possible, I hope to answer some practical questions I had when I started reading up on the topic. Like these:</p>
<ul>
<li><p>How are quantum computers built?</p></li>
<li><p>Are we going to have quantum laptops any time soon?</p></li>
<li><p>How can I get my hands dirty with quantum computing today? What do I need to understand to write my first “Hello world” quantum computing program?</p></li>
<li><p>What advantages, if any, does quantum computing offer? This topic is key to the whole thing, but I’m going to skip over it very lightly here. Maybe a Part II will discuss it in more depth.</p></li>
<li><p>What is the status and prospects of quantum computing today? Well, an answer is too much to hope for, but I’ll offer some reflections.</p></li>
</ul>
<p>But let’s start with three building blocks of quantum computers: qubits, gates, and circuits.</p>
</section>
<section id="the-building-block" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> The building block</h1>
<section id="qubits" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="qubits"><span class="header-section-number">2.1</span> Qubits</h2>
<p>Regular computers are built around bits, quantum computers are built around qubits. So what does that mean?</p>
<p>The archetypal example of a qubit is an atomic nucleus with a spin of ½, like the <sup>89</sup>Y isotope of Yttrium (although many quantum computers don’t actually use spin-½ nuclei, but let’s put that aside for now). The spin means that the nucleus has angular momentum, as if it were an electrical charge spinning in one direction or the other. This spinning electrical charge creates a little magnet that can be pointing either “up” or “down”.</p>
<p>(Aside: classically, the axis around which the rotation happens is the “direction” of angular momentum, which is a bit odd when you first come across it. Angular momentum in quantum mechanics follows the same rule. Similarly, a classical electric current moving in a circle creates a magnetic field. So quantum spin, a form of angular momentum, is following similar rules as classical angular momentum. A big difference, though, is that classical angular momentum can take any value–a bicycle wheel can spin at any speed–but quantum spin can take only specific discrete values (it is “quantized”): in the case of a spin-½ particle that is +½ or -½, which we usually call “spin up” or “spin down”. These two values can represent <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span> when used as a qubit in a quantum computer, just as a classical “bit” might be a transistor that can take on a state of “on” or “off”. It’s often said that an electron or nucleus with angular momentum is like a little ball spinning around an axis, except that it’s not a ball and it’s not spinning.)</p>
<p>Qubits, as has often been said, exist in a state that is a <em>superposition</em> of 0 and 1, but let’s leave that to one side for now as well.</p>
<div id="fig-spin" class="quarto-float quarto-figure quarto-figure-center anchored" alt="An archetypal qubit: an atom with nuclear spin up or down">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-spin-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/clipboard-2996633943.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Figure&nbsp;1: An archetypal qubit: an atom with nuclear spin up or down"><img src="images/clipboard-2996633943.png" class="img-fluid figure-img" alt="An archetypal qubit: an atom with nuclear spin up or down" width="300"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spin-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: An archetypal qubit: an atom with nuclear spin up or down
</figcaption>
</figure>
</div>
<p>Qubits may be atomic nuclear spins, using nuclear magnetic resonance, but in principle any other system that displays this two-level behaviour can be used as a qubit. Some research groups have built quantum computers with atomic-scale qubits, like arrays of charged ions trapped in space by electromagnetic fields (e.g., <a href="https://www.quantinuum.com/">Quantinuum</a> or <a href="https://ionq.com/">IonQ</a>) or arrays of neutral atoms (e.g.&nbsp;<a href="https://www.quera.com/">QuEra</a>). Others (e.g.&nbsp;Google and IBM) are exploiting macroscopic quantum phenomena – for example, qubits based on superconductivity in circuits of maybe a micrometre in size: the current in a superconductor is macroscopic (although still small by our standards) but is quantized. And there are other approaches too : photonics (e.g.&nbsp;<a href="https://photonic.com/">Photonic</a> and <a href="https://www.xanadu.ai">Xanadu</a>), topological “anyons” (Microsoft) and more. These different approaches are often called “modalities” in industry jargon.</p>
<p>A feature of quantum computing is its division of intellectual and physical labour. Some people build quantum computers using a particular modality, and learn how to work with the components that they need. Others spend their time developing quantum algorithms that could, in principle, run on a quantum computer built with any of these modalities.</p>
<p>The large number of qubit “modalities” being pursued is often seen as a strength of the field, a sign of its vitality, and this makes sense from a “don’t put all your eggs in one basket” perspective. The number of modalities increases the chance that one of them will surely a scalable quantum computer. But I wonder… is it also a sign of the uncertainty that remains? After all, if there were a clear path from a particular modality to a general purpose quantum computer, then the industry would have coalesced around that modality. The number of modalities being actively pursued suggests that each has obstacles that it has not yet surmounted. It would be interesting to chart the progress in the industry, not by what each company and research group says about its own modality and its own breakthroughs, but by what they each say about the limitations of everyone else who is competing for the same funds. But OK, back to quantum computing proper.</p>
</section>
<section id="gates" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="gates"><span class="header-section-number">2.2</span> Gates</h2>
<p>Whatever approach you choose, you want to build a computer out of these qubits. So the next thing you need for a computer is logic gates. In a classical computer the simplest gate is this NOT gate.</p>
<div id="fig-not" class="quarto-float quarto-figure quarto-figure-center anchored" alt="A NOT gate, which turns 0 into 1 and vice versa">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-not-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/clipboard-1114991653.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Figure&nbsp;2: A NOT gate, which turns 0 into 1 and vice versa"><img src="images/clipboard-1114991653.png" class="img-fluid figure-img" alt="A NOT gate, which turns 0 into 1 and vice versa" width="300"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-not-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: A NOT gate, which turns 0 into 1 and vice versa
</figcaption>
</figure>
</div>
<p>The NOT gate has one input and one output. If the input is 0, then the output is 1, and if the input is 1 then the output is 0.</p>
<p>In classical computers, the lines are wires and the shield-symbol is etched into a chip and the bits are charges moving through the gates. In the world of quantum computers, the qubits stay where they are: it’s called “in-place computing”. If you shine a laser at one particular qubit and cause it to flip from one of its states to the other, then that’s like a NOT gate: it turns a 0 into 1 or a 1 into 0. In quantum computing circuit diagrams, the lines are not wires, they are <em>before</em> and <em>after</em> states of the qubit.</p>
<p>(In the figure above, the state of each qubit is represented in what’s called the “Dirac ket notation”, like <span class="math inline">\(| \uparrow \rangle\)</span> or, equivalently, <span class="math inline">\(| 1 \rangle\)</span>. This notation is really useful and standard in all areas of quantum mechanics, but here it’s just a symbol that shows the value of a qubit.)</p>
<p>Most classical gates, like XOR and NAND, have two inputs, and many quantum gates can also have two inputs. Here is a “Controlled NOT gate” or CNOT gate, which is an important component of quantum computers. If the top qubit is spin down (0), the bottom qubit is unchanged. If the top qubit is spin up (1), the bottom qubit is flipped.</p>
<div id="fig-cnot" class="quarto-float quarto-figure quarto-figure-center anchored" alt="A CNOT gate (conditional NOT) which flips the state of the target qubit only if the state of the control qubit is 1.">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cnot-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/clipboard-2084024626.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Figure&nbsp;3: A CNOT gate (conditional NOT) which flips the state of the target qubit only if the state of the control qubit is 1."><img src="images/clipboard-2084024626.png" class="img-fluid figure-img" alt="A CNOT gate (conditional NOT) which flips the state of the target qubit only if the state of the control qubit is 1." width="300"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cnot-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: A CNOT gate (conditional NOT) which flips the state of the target qubit only if the state of the control qubit is 1.
</figcaption>
</figure>
</div>
<p>Again, if this were a classical computing gate, the “bits” would be charges travelling along wires, going in to the gate from the left and out on the right. But in quantum computing the gate is not a feature of a circuit etched into a chip. It’s an operation—a combination of laser or microwave pulses that changes the state of the qubits from a before state (on the left) to an after state (on the right)—and the qubits stay in place.</p>
<p>Before moving on, I should mention one gate you will see all the time in quantum computing, but not in classical computing. It’s called the Hadamard gate. If you prepare an input qubit in state <span class="math inline">\(| \uparrow \rangle\)</span> then a Hadamard gate puts it into a superposition of states. Many circuits start with Hadamard gates way to take advantage of this superposition. I just mention this because it is useful and ubiquitous, and also because it is needed in the next section.</p>
<div id="fig-hadamard" class="quarto-float quarto-figure quarto-figure-center anchored" alt="A Hadamard gate takes a pure state as input and converts it into a superposition of states">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-hadamard-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/clipboard-2752364083.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Figure&nbsp;4: A Hadamard gate takes a pure state as input and converts it into a superposition of eigenstates"><img src="images/clipboard-2752364083.png" class="img-fluid figure-img" alt="A Hadamard gate takes a pure state as input and converts it into a superposition of states" width="300"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-hadamard-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: A Hadamard gate takes a pure state as input and converts it into a superposition of eigenstates
</figcaption>
</figure>
</div>
</section>
<section id="circuits" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="circuits"><span class="header-section-number">2.3</span> Circuits</h2>
<p>Once you have qubits and gates, the next thing to do is implement algorithms. In classical computers you have a fixed circuit and programming instructions send bits through these fixed gates to implement an algorithm. In a quantum computer, you start with a set of qubits in a prepared state (usually all <span class="math inline">\(|0\rangle\)</span>), and apply a sequence of gate operations and then measure the output. So a circuit is how you implement an algorithm.</p>
<p>Here is a circuit diagram for a quantum fourier transform (QFT), which turns out to be important in the Shor algorithm for factoring integers. You have <span class="math inline">\(n\)</span> qubits, you prepare them in some initial state <span class="math inline">\(| x_i \rangle\)</span>, you subject them to a series of gates, and you end up with some outputs which you measure.</p>
<div id="fig-qft" class="quarto-float quarto-figure quarto-figure-center anchored" alt="A circuit for a quantum Fourier transform">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-qft-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/clipboard-1213033795.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Figure&nbsp;5: A circuit for a quantum Fourier transform. Source: Wikimedia Commons"><img src="images/clipboard-1213033795.png" class="img-fluid figure-img" alt="A circuit for a quantum Fourier transform"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-qft-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: A circuit for a quantum Fourier transform. Source: Wikimedia Commons
</figcaption>
</figure>
</div>
<p>To be useful, a quantum computer would need many qubits and many gates, and so far there are strict limits on how many qubits can be assembled, and how many gates can operate on them before they lose their well-defined state. How many and why? We’ll come to that later on.</p>
</section>
</section>
<section id="will-i-have-a-quantum-laptop-no" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Will I have a quantum laptop? (No)</h1>
<p>When I started looking at quantum circuit diagrams I thought it contradicted the idea of quantum computers as general purpose computers, because you need different circuits for different algorithms and I assumed that any computer would have a fixed set of circuits (like CPU circuits are etched into silicon) and hence be limited in what algorithms it can execute.</p>
<p>But once I realised that a circuit is not a permanent thing but is instead a sequence of operations (gates) that implement an algorithm, then I realised it’s not a contradiction at all.</p>
<p>Perhaps I’m belabouring this point, but for some reason, many introductions to quantum computing seem to skip over this difference between regular electrical circuits, and “quantum circuits”. I read several before I realized what was going on.</p>
<p>So are quantum computers general purpose? Well yes and no. Formally, they are. That is, there is a set of gates (different to the gates for classical computing) which satisfy the requirements for Turing completeness. So that’s nice.</p>
<p>But what about “general purpose” in the more everyday, practical sense? Let’s go back to how you build quantum computers. No matter what approach you take, the set of qubits must exist in what is called a single “quantum state”, and quantum states fall apart or “decohere” if they interact with the wider world, so they have to be isolated. Also, thermal energy (which is just one form of interaction with the wider world, of course) will jiggle these qubits among the states and you can’t have that, so quantum computers have to be operated at very low temperatures, meaning about 1K.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>This fragility of quantum states has consequences:</p>
<ul>
<li><p>You won’t, in the foreseeable future, have a quantum computing laptop. Quantum computers need cooling and will be built in fixed locations.</p></li>
<li><p>It’s going to be expensive to build them. And so your company probably won’t be buying many quantum computers any time soon. It makes sense to have specialised providers who will provide time on them through a cloud service.</p></li>
<li><p>For any algorithm that can be executed either classically or in a quantum computer, classical is going to be roughly a gazillion times cheaper for the foreseeable future. You won’t be running most of your code on a quantum computer.</p></li>
</ul>
<p><em>BUT</em> there are certain tasks that <em>may</em> be done more quickly on a quantum computer than on a classical one, if a powerful enough quantum computer can be built. So what will most likely happen is that specific function calls within a larger program may be executed on a quantum computer, and the rest will be done on a classical one.</p>
<div id="fig-cloud" class="quarto-float quarto-figure quarto-figure-center anchored" data-ig-alt="Quantum computers are most likely to be made available as cloud services, to augment existing classical computing cloud services">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cloud-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/clipboard-2267828356.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Figure&nbsp;6: Quantum computers are most likely to be made available as cloud services, to augment existing classical computing cloud services"><img src="images/clipboard-2267828356.png" class="img-fluid figure-img" data-ig-alt="Quantum computers are most likely to be made available as cloud services, to augment existing classical computing cloud services" width="300"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cloud-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Quantum computers are most likely to be made available as cloud services, to augment existing classical computing cloud services
</figcaption>
</figure>
</div>
<p>The emerging paradigm, at least as at October 2024, is of a cloud-hosted data centre where an application can use classical computers for many parts of an application, but have access to quantum computers to run specific functions. Perhaps it’s not surprising that Microsoft, IBM, and Google are at the forefront and Amazon (AWS) is now investing heavily: they want to host them, and rent them out to their cloud users.</p>
</section>
<section id="how-to-program-a-quantum-computer" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> How to program a quantum computer</h1>
<p>The companies providing quantum computers want people to use them, so they provide libraries or modules that you can use. For example, Google and IBM provide python libraries (<a href="https://quantumai.google/cirq">cirq</a> and <a href="https://www.ibm.com/quantum/qiskit">Qiskit</a>, respectively) and Microsoft provides its own <a href="https://learn.microsoft.com/en-ca/azure/quantum/install-overview-qdk">Quantum Development Kit</a>. These libraries provide an interface to the host quantum computers and, more practically for most of us, provide a way to simulate quantum computing on a local classical computer, for small cases.</p>
<p>So here is some code that uses Google’s <em>cirq</em> library for python. It defines two qubits and a list of gates that operate on those qubits. Then it creates a circuit from the gates, and runs the circuit on a simulator on your local computer. As the algorithm is very simple, the quantum computation can easily be simulated on a classical computer. If you’re familiar with the python programming language, you can easily install <code>cirq</code> by typing <code>pip install cirq</code> at a command prompt. Here is a “hello world” example to give you an idea of what the code looks like, which each step described by a comment.</p>
<p>Providing quantum computing at the level of a library makes it possible to implement hybrid applications (which, as the last section showed, are the most likely form) with the quantum components implemented as functions of a largely-classical application.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cirq</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Define two qubits</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>q_control <span class="op">=</span> cirq.NamedQubit(<span class="st">'control'</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>q_target <span class="op">=</span> cirq.NamedQubit(<span class="st">'target'</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Define a list of gates: a "Hadamard" gate on each qubit, </span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># followed by a CNOT gate, and then a measurement of the </span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># control qubit q_control.</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>gates <span class="op">=</span> [</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        cirq.H(q_control), </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        cirq.H(q_target), </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        cirq.CNOT(q_control, q_target), </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        cirq.measure(q_control)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a circuit from this list of gates</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>circuit <span class="op">=</span> cirq.Circuit(gates)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(circuit)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate the execution of the circuit</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>simulator <span class="op">=</span> cirq.Simulator()</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> simulator.run(circuit)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The “print” instructions display an ascii-art rendering of the circuit and the results. I found this exercise helpful, to see how an end user might construct a circuit in software and run it (albeit on a simulator). It does prompt the question: if all the quantum algorithms are going to be expressed in this unfamiliar circuit form, how expressive is this language? There is a big gap between “it’s a formally complete set of gates so you can do anything this way” and any more practical statement about real implementations.</p>
</section>
<section id="why-might-quantum-computing-matter" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Why might quantum computing matter?</h1>
<p>Building a new kind of computer, defining new ways to express algorithms, providing new coding libraries, integrating computers with existing cloud services… this is all a lot of work. Why would you bother? Only because quantum computing has been shown to have an intrinsic advantage over classical computing, in principle, for certain kinds of problem. If I write up Part II of this introduction (link to come) then it will describe this advantage in detail, but here we shall skip lightly over the essential details. They are available in many other places anyway. The goal here is to get down the basic minimum that I needed to understand some of the descriptions you see elsewhere.</p>
<section id="superposition-and-interference" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="superposition-and-interference"><span class="header-section-number">5.1</span> Superposition and interference</h2>
<p>The idea of quantum advantage relies on a combination of two phenomena that are consequences of the wave/particle nature of quantum systems.</p>
<p>One is that qubits exist in <em>superpositions</em> of states. That is, although any measurement of the qubit will show it to be in state <span class="math inline">\(| \uparrow \rangle\)</span> or <span class="math inline">\(| \downarrow \rangle\)</span>, in general the qubit can be in a state that is a superposition of these two, and it has what is called a wavefunction or (equivalently) a state vector <span class="math inline">\(| \psi \rangle\)</span> (the Greek letter <em>psi</em>) given by:</p>
<p><span class="math display">\[
| \psi \rangle = \alpha | \uparrow \rangle + \beta | \downarrow \rangle
\]</span></p>
<p>The <span class="math inline">\(| \uparrow \rangle\)</span> and <span class="math inline">\(| \downarrow \rangle\)</span> states, which are the only possible outcomes of measurement, are called <em>eigenstates</em> or, sometimes, <em>basis states</em> <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. The coefficients <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> are <em>probability amplitudes</em>, meaning that in any measurement of the state of <span class="math inline">\(| \psi \rangle\)</span> the probability of seeing state <span class="math inline">\(|\uparrow \rangle\)</span> is <span class="math inline">\(\alpha^2\)</span> and the probability of seeing state <span class="math inline">\(| \downarrow \rangle\)</span> is <span class="math inline">\(\beta^2\)</span>. Sometimes these are also called <em>phases</em>. This is something you just have to take on trust unless you want to dive properly into quantum mechanics.</p>
<p>Some influential descriptions say that quantum computers carry out many calculations in parallel, and this notion of superposition is where the idea of quantum parallelism comes from: that you can act on <span class="math inline">\(| \uparrow \rangle\)</span> and <span class="math inline">\(| \downarrow \rangle\)</span> at the same time because the qubit is in a superposition of states. You may even have heard some people talk about “many worlds” interpretations of quantum mechanics in which qubits are simultaneously “computing” each possible value of <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> in different universes.</p>
<p>I really think it is best to put these aside as unnecessary (and unjustified) science-fiction-inspired enthusiasms. Practically, from what I can see, superposition alone does not deliver massive parallelism. First, the qubit is not “in both states at once”, it is in one state with one probability, and the other state with a different probability, and in any measurement you only ever see either one of the two eigenstates <span class="math inline">\(| 0 \rangle\)</span> or <span class="math inline">\(| 1 \rangle\)</span>: you can only ever get one bit of information out of qubit. (This is far from an original observation.)</p>
<p>The second quantum phenomenon is <em>interference</em>, and here things get more messy. First, there is the notion of a quantum “state”: a system is only “in a (pure) quantum state” if it is isolated from the rest of the world. So quantum computing requires that the whole array of qubits be represented by a single quantum state. But the requirement is stronger than that: individual qubits have to be isolated from each other except when subjected to the operations of a gate. And the operations of a gate must be able to address pairs of qubits in such a way that none of the other qubits are touched, but the two addressed make up a pure quantum state. Under these circumstances, the two qubits interfere with each other, and so become, as they say, entangled. For example, here is a two-particle state called a “Bell state”. The individual qubits may be spin up or spin down, and the very fact that we can write a state vector for the two qubits implies that they are effectively isolated from other qubits. But if you measure one of them, you know the second.</p>
<p><span class="math display">\[
| \psi \rangle = \alpha | \uparrow \uparrow \rangle + \beta | \downarrow \downarrow \rangle
\]</span></p>
<p>The system exists in a superposition of the two states, so neither qubit has a fixed value until it is measured. But if you measure the value of the spin for one particle (for example, the first) then you know the value for the other particle. Said this way, it sounds like there is no more to interference than “if I pull a left-footed shoe out of the box, then I know that the other shoe is right-footed”. There is more, but we can ignore it for most purposes.</p>
<p>(I am of a generation that was taught quantum mechanics without ever hearing the word “entanglement” outside evening pub talk, so I have something of an inbuilt reservation to using it unless it is really needed. I feel that much of what is meant by “entanglement” can be described as interference. But I may be wrong!)</p>
<p>If you do want to go into the world of entanglement, the best popular treatment I have read is <a href="https://press.uchicago.edu/ucp/books/book/chicago/B/bo28254471.html">Beyond Weird</a>, by Philip Ball.</p>
<p>Quantum computing relies on some clever ideas to combine the effects of superposition and interference so as to extract information from a set of qubits (by applying a sequence of gates and ending in measurements) that you could not get from classical bits.</p>
</section>
<section id="the-deutsch-algorithm" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="the-deutsch-algorithm"><span class="header-section-number">5.2</span> The Deutsch algorithm</h2>
<p>The Deutsch algorithm was the first (1992) to suggest we could use these quantum phenomena to solve a problem more efficiently that one could do with a classical computer. The idea was to pose a question, no matter how artificial and useless, which quantum computers might be able to answer quicker than classical computers. And then maybe that will give us insights we can use to get to some useful questions later on.</p>
<p>Here is the artificial and useless problem Deutsch chose (that is not a criticism). There are four possible functions that can act on a bit data type and produce a bit output.</p>
<table class="caption-top table">
<caption>The four functions that take a bit as input and produce a bit as output</caption>
<thead>
<tr class="header">
<th style="text-align: right;">Input</th>
<th style="text-align: right;"><span class="math inline">\(f_0\)</span></th>
<th style="text-align: right;"><span class="math inline">\(f_1\)</span></th>
<th style="text-align: right;"><span class="math inline">\(f_x\)</span></th>
<th style="text-align: right;"><span class="math inline">\(f_{\hat{x}}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
</tr>
<tr class="odd">
<td style="text-align: right;"></td>
<td style="text-align: right;">Constant</td>
<td style="text-align: right;">Constant</td>
<td style="text-align: right;">Balanced</td>
<td style="text-align: right;">Balanced</td>
</tr>
</tbody>
</table>
<p>One question would be: if you have a black box that implements a function <span class="math inline">\(f\)</span> and just look at the inputs and outputs, can you tell which function is in the black box? But Deutsch picked out an even more obscure question: <span class="math inline">\(f_0\)</span> and <span class="math inline">\(f_1\)</span> are constant and <span class="math inline">\(f_x\)</span> and <span class="math inline">\(f_{\hat{x}}\)</span> are “balanced”, which is that they have one of each. If you have a black box and just look at the inputs and outputs, can you tell if <span class="math inline">\(f\)</span>, the function inside, is one of the even functions or one of the balanced functions?</p>
<p>Classically you need to pose two queries: what’s <span class="math inline">\(f(0)\)</span> and what’s <span class="math inline">\(f(1)\)</span>? And in a quantum circuit the naive way would also take two queries: as the measurement will only give either <span class="math inline">\(f(0)\)</span> or <span class="math inline">\(f(1)\)</span> with probability <span class="math inline">\(a^2\)</span> or <span class="math inline">\(b^2\)</span>, it seems you still need to make at least two measurements to find out whether <span class="math inline">\(f\)</span> is constant or balanced (an illustration that superposition, by itself, does not enable parallel computation on all its states). But Deutsch came up with an idea that you could use an extra qubit and combine the effects of superposition and interference to get the answer with just one query.</p>
<p>And here is the algorithm to solve it, represented by a circuit.</p>
<div id="fig-deutsch" class="quarto-float quarto-figure quarto-figure-center anchored" alt="The circuit diagram for an algorithm to solve Deutsch's problem with a single measurement">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-deutsch-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/clipboard-2152342130.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Figure&nbsp;7: The circuit diagram for an algorithm to solve Deutsch’s problem with a single measurement"><img src="images/clipboard-2152342130.png" class="img-fluid figure-img" alt="The circuit diagram for an algorithm to solve Deutsch's problem with a single measurement" width="500"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-deutsch-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7: The circuit diagram for an algorithm to solve Deutsch’s problem with a single measurement
</figcaption>
</figure>
</div>
<p>I won’t go through this now (many other places do, and maybe I’ll have a go in Part II, but no promises), but with this circuit just one measurement of the top qubit will tell you whether the black box, labelled here as an “Oracle”, represents a constant or a balanced function. So you can use a combination of superposition and interference to do things you can’t do on a classical computer.</p>
</section>
<section id="the-canonical-algorithms" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="the-canonical-algorithms"><span class="header-section-number">5.3</span> The canonical algorithms</h2>
<p>Since then, a handful of algorithms have been developed that are particularly interesting. The recent book <a href="https://link.springer.com/book/10.1007/978-3-030-23922-0">Quantum Computing: An Applied Approach</a> calls them the canon.</p>
<p>These are algorithms for which it has been proved that an ideal quantum computer would offer an algorithm of less complexity than a classical computer.</p>
<ul>
<li><p>The big one is the Shor algorithm, which shows how to factor a large number in polynomial time rather than exponential time. And as that is the root of public key encryption schemes there is a lot of excitement.</p></li>
<li><p>Another algorithm is the Variational Quantum Eigensolver (VQE). When you see statements like “Quantum computing plays a role in drug discovery and the design of new materials”, this is the technique most aligned with that goal.</p></li>
<li><p>A third is the Quantum Approximate Optimization Algorithm (QAOA). When you see claims that “quantum computing will revolutionize logistics and financial portfolio management” this is the technique to think of.</p></li>
<li><p>And a fourth is the Grover search algorithm for finding an item in an unstructured database.</p></li>
</ul>
<p>But let’s be clear: <em>none of these shows real-world benefit compared to classical computing yet</em>. In particular, despite the progress of quantum computing so far, the biggest number to be factored by a quantum computer a manner that may scale to large numbers seems to be a less-than-impressive 21. And while quantum computing experts say that this does not matter, and that there are technical reasons to focus on other metrics for progress, to me this sounds a bit like they are <a href="https://en.wikipedia.org/wiki/Streetlight_effect">looking under the street light for their keys</a>.</p>
</section>
<section id="quantum-simulation" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="quantum-simulation"><span class="header-section-number">5.4</span> Quantum simulation</h2>
<p>A side note: you may see some bigger numbers reported for D-Wave systems. There’s no time to talk about that here, but <a href="https://www.dwavesys.com/">D-Wave</a> is a Canadian company that has taken a different path to quantum computing. It uses quantum simulation, or quantum annealing, which is a separate approach to exploiting quantum phenomena to solve optimization problems. It does not involve gates, and is not a universal model of computation.</p>
<p>I think the idea is that many optimization problems are analogous to finding the ground state of a lattice of qubits (so-called “Ising problems”). The approach is to match the problem of interest to a lattice, build this lattice of qubits in the quantum computing device, cool it down, and see where it settles. Than match that back to the problem of interest to get the solution.</p>
<p>D-Wave have build computers, or simulators, using this approach with superconducting circuits as their qubits. It seems to be true that D-Wave can tackle many problems that other quantum computers cannot, but it remains an open question whether D-Wave machines really show a quantum advantage over classical computers.</p>
</section>
</section>
<section id="quantum-computing-in-2024" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Quantum computing in 2024</h1>
<p>So where are we when it comes to building real quantum computers that can handle problems of interest? There are several metrics of interest: here are three (I’m sure there are others).</p>
<ul>
<li><p>Number of qubits. But implicit in the discussion above is that a qubit behaves well: that it is in one well-defined quantum state and stays there. In practice, a distinction is needed between “physical qubits” which may be less-than-perfect, and “logical” or “error-corrected” qubits, which behave properly.</p></li>
<li><p>Number of gates. To be able to operate on an array of qubits with a succession of gates is demanding. Not all systems can stay “coherent” for the length of time it takes to apply a number of gates. So it is not at all clear that once you have a large number of qubits, even if they are properly error-corrected, you have a successful quantum computer.</p></li>
<li><p>Connectivity. Not all quantum computers allow you to implement the same set of gates, and even if you can, for some a “gate” may be a complex, multi-step operation in practice. And in some architectures / modalities, only qubits “near” each other can be used in a particular gate. And some algorithms assume three-qubit gates, which introduces even more complexity. So you may see reference to “transpiling” algorithms, which means taking a quantum circuit and re-expressing it in terms of the gates that you have at hand on a particular quantum computer.</p></li>
</ul>
<p>There is a tension relevant for building quantum computers. You need the whole circuit to be a single state, which means no interference from the environment. Yet at the same time you are poking it and prodding it with these gates, which are very explicit interactions with the environment.</p>
<p>Also: no quantum state is really just two states that you can pick between. There are higher energy states that start to get populated as the temperature increases, and which mess things up.</p>
<p>So error correction is a big part of any quantum computing effort. And typically the answer is the same as any other error correction system: redundancy. So there is a distinction between physical qubits (which are the building blocks we have talked about) and logical qubits, which are collections of physical qubits that you can trust to behave in the way the theory needs. So how many logical qubits to a single physical qubit? Depends on the approach, but <a href="https://www.nature.com/articles/s41586-023-06927-3">the leading work</a> says at least 50.</p>
<section id="current-state-of-the-art" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="current-state-of-the-art"><span class="header-section-number">6.1</span> Current state of the art</h2>
<p>Leading implementations have about a thousand qubits with gate times of 10 ns and what is called “gate fidelity” of three nines. These have all come a long way in the last decade.</p>
<p>Google made big claims four years ago with a 53-noisy qubit processor. They said it could do this task which it would take a classical computer 10,000 years to accomplish. But it’s fundamentally not a very useful task, so no one has really thought much about the best way to do the task on a classical computer. IBM, who is competing with Google of course, came back a short time later and said “we could do that in 2 ½ days”, and another group claimed five minutes. So not convincing yet.</p>
<p>But scale is an important open question. Because we need to get up to at least 10,000 logical qubits to be of any use, and probably into the millions. And despite what Time Magazine says, we are a long way away. And progress is progress, but we can’t assume a Moore’s Law progression yet.</p>
</section>
</section>
<section id="the-big-question" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> The big question</h1>
<p>So far quantum computing has delivered a set of proofs of concept, together with road maps for scaling up that give an optimistic sense of predictability, when there are still fundamental unknowns to resolve.</p>
<div id="fig-venn" class="quarto-float quarto-figure quarto-figure-center anchored" alt="Are there problems for which quantum computers have an advantage, and which we care about?">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-venn-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/clipboard-3333356435.png" class="lightbox" data-gallery="quarto-lightbox-gallery-8" title="Figure&nbsp;8: Are there problems for which quantum computers have an advantage, and which we care about?"><img src="images/clipboard-3333356435.png" class="img-fluid figure-img" alt="Are there problems for which quantum computers have an advantage, and which we care about?"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-venn-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8: Are there problems for which quantum computers have an advantage, and which we care about?
</figcaption>
</figure>
</div>
<p>We know there are problems for which there is quantum advantage. We know we can build some of these, like the Google sampling problem, but like the Deutsch algorithm these are mainly artificial. And we know there are problems we care about that have the potential for quantum advantage.</p>
<p>What we don’t know is whether we are on the left or the right side of this diagram. Or, to put it differently, how long we will be on the left side. It’s not a resolved question, and it’s not likely to be resolved soon. But don’t take this from me! Here is a recent quotation from <a href="https://scottaaronson.blog/">Scott Aaronson</a>, who did a postdoc near me at the University of Waterloo before going on to become one of the leaders in the field of quantum algorithms.</p>
<blockquote class="blockquote">
<p>“Billions of dollars [are] being invested in quantum computing… in the hope that a quantum computer would accelerate machine learning, optimization, financial problems, AI problems…. As here, as a quantum algorithms person, honesty compels me to report to you that the situation is much, much iffier.”</p>
</blockquote>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>This is not quite true for all modalities: computers built using photonic qubits are not subject to this low-temperature requirement, but they do have other challenges.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>The phrase “basis states” has somewhat different meanings in other areas of quantum mechanics, but usually in quantum computing it refers to the measurement states.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>2023 – 2024, Tom Slee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","openEffect":"zoom","selector":".lightbox","loop":false});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>